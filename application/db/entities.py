import json
import logging
from datetime import datetime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, Table, DateTime, ForeignKeyConstraint
from sqlalchemy.types import Boolean, Text
from sqlalchemy.orm import relationship
from enum import Enum
from typing import List, Tuple
from application.db.owner_member import OwnerMember
from application.db.roles import Roles

Base = declarative_base()

user_project_role_table = Table(
    "user_project_role",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("user.id"), primary_key=True),
    Column("role_id", String(20), ForeignKey("role.id"), primary_key=True),
    Column("project_id", Integer, ForeignKey("project.id"), primary_key=True),
)

user_team_role_table = Table(
    "user_team_role",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("user.id"), primary_key=True),
    Column("role_id", String(20), ForeignKey("role.id"), primary_key=True),
    Column("team_id", Integer, ForeignKey("team.id"), primary_key=True),
)

api_key_project_table = Table(
    "api_key_project",
    Base.metadata,
    Column("api_key_id", Integer, ForeignKey("api_key.id")),
    Column("project_id", Integer, ForeignKey("project.id")),
)

user_subscription_tracking_table = Table(
    "user_subscription_tracking",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("user.id")),
    Column("subscription_tracking_id", Integer, ForeignKey("subscription_tracking.id")),
)

class Entity(Base):
    """
        id: Entity id, numeric, unique for a given entity type, and autogenerated.
            Note that IDs are populated once session.flush() is performed.
    """
    __abstract__ = True

    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.now())
    active = Column(Boolean, unique=False, default=True)
    public = Column(Boolean, unique=False, default=False)
    description = Column(Text)

    def __init__(self, **kwargs):
        for k,v in kwargs.items():
            setattr(self, k, v)

    def __eq__(self, other):
        return other is not None and self.__class__ == other.__class__ and self.id == other.id

    def __hash__(self):
        return hash(f"{self.__class__.__name__}{self.id}")

    def get_dict(self):
        d = self.__dict__.copy()
        if "_sa_instance_state" in d:
            del d["_sa_instance_state"]
        return d

class UserEntity(Entity):
    __tablename__ = "user"
    __mapper_args__ = {"concrete": True}

    creator_id = Column(Integer, ForeignKey("user.id"), nullable=True )
    user_name = Column(String(255))
    given_name = Column(String(100))
    family_name = Column(String(100))
    system_admin = Column(Boolean, default=False)
    subscription_id = Column(Integer, ForeignKey("subscription.id"))

    teams = relationship("TeamEntity", secondary=user_team_role_table, lazy="joined")
    projects = relationship("ProjectEntity", secondary=user_project_role_table, lazy="joined")
    subscription = relationship("SubscriptionEntity")
    subscription_tracking = relationship("SubscriptionTrackingEntity", \
            secondary=user_subscription_tracking_table, lazy="joined")

class RoleEntity(Entity):
    __tablename__ = "role"
    __mapper_args__ = {"concrete": True}

    id = Column(String(20), primary_key=True)
    name = Column(String(20))

class Restricted(Entity):
    __abstract__ = True

    @property
    def om(self):
        if not hasattr(self, "_om"):
            self._om = OwnerMember(self)
        return self._om

    def count_users(self, session):
        return len(self.get_id_roles(session))

    def can_update_or_delete(self, uid, session):
        return self.om.can_update_or_delete(uid, session)

    def get_owner_ids(self, session):
        return self.om.get_owner_ids(session)

    def get_id_roles(self, session) -> List[Tuple[int,str]]:
        return self.om.get_id_roles(session)

    def get_member_ids(self, session):
        return self.om.get_member_ids(session)

    def get_viewer_ids(self, session):
        return self.om.get_viewer_ids(session)

    def make_owner(self, uid, session) -> None:
        return self.om.make_owner(uid, session)

    def make_member(self, uid, session) -> None:
        return self.om.make_member(uid, session)

    def make_viewer(self, uid, session) -> None:
        return self.om.make_viewer(uid, session)

    def remove_user_with_role(self, uid, session) -> None:
        return self.om.remove_user_with_role(uid, session)

    def is_user_in(self, uid, session) -> bool:
        return self.is_owner(uid,session) or self.is_member(uid,session) or self.is_viewer(uid, session)

    def is_owner(self, uid, session) -> bool:
        return uid in self.get_owner_ids(session)

    def is_member(self, uid, session) -> bool:
        return uid in self.get_member_ids(session)

    def is_viewer(self, uid, session) -> bool:
        return uid in self.get_viewer_ids(session)


class TeamEntity(Restricted):
    __tablename__ = "team"
    __mapper_args__ = {"concrete": True}

    name = Column(String(100))
    creator_id = Column(Integer, ForeignKey("user.id"), nullable=True )

    users = relationship("UserEntity", secondary=user_team_role_table, lazy="joined")
    projects = relationship("ProjectEntity", lazy="joined")

class ProjectEntity(Restricted):
    __tablename__ = "project"
    __mapper_args__ = {"concrete": True}

    name = Column(String(100))
    creator_id = Column(Integer, ForeignKey("user.id") )
    team_id = Column(Integer, ForeignKey("team.id"))

    team = relationship("TeamEntity")
    users = relationship("UserEntity", secondary=user_project_role_table, lazy="joined")
    keys = relationship("ApiKeyEntity", secondary=api_key_project_table, lazy="joined")

class ApiKeyEntity(Entity):
    __tablename__ = "api_key"
    __mapper_args__ = {"concrete": True}

    key = Column(String(36), nullable=False )
    name = Column(String(100))
    creator_id = Column(Integer, ForeignKey("user.id"), nullable=True )

    projects = relationship("ProjectEntity", secondary=api_key_project_table, lazy="joined")

class SubscriptionEntity(Entity):
    __tablename__ = "subscription"
    __mapper_args__ = {"concrete": True}

    users = Column(Integer, default=0 )
    """ max root count across all projects """
    roots = Column(Integer, default=0 )
    """ max projects across all teams """
    projects = Column(Integer, default=0 )
    """ max teams made by the subscription holder """
    teams = Column(Integer, default=0 )
    """ max team members in a team """
    team_members = Column(Integer, default=0 )
    """ max docs total across all roots """
    docs = Column(Integer, default=0 )
    """ max size of uploaded docs """
    each_doc_bytes = Column(Integer, default=0 )
    """
    the total number of bytes for all docs in projects
    where the creator_id is a user with this
    subscription_tracking table entry. if I upload a doc
    we look for my subscription_tracking entry and
    increment this counter. this implies that all users
    created by a subscription holder have a pointer to
    their subscription_tracking entry
    """
    total_doc_bytes = Column(Integer, default=0 )
    """ max api keys across all projects """
    api_keys = Column(Integer, default=0 )
    """ max api calls within a timeframe """
    api_calls = Column(Integer, default=0 )
    """ indicates when api_calls resets """
    api_cycle = Column(String(20), nullable=False, default="Monthly" )
    """ indicates length of a subscription -- Monthly, Annual """
    subscription_cycle = Column(String(20), nullable=False, default="Monthly" )
    name = Column(String(100))

class SubscriptionTrackingEntity(Entity):
    __tablename__ = "subscription_tracking"
    __mapper_args__ = {"concrete": True}

    users = Column(Integer, default=0 )
    roots = Column(Integer, default=0 )
    projects = Column(Integer, default=0 )
    teams = Column(Integer, default=0 )
    docs = Column(Integer, default=0 )
    total_doc_bytes = Column(Integer, default=0 )
    api_keys = Column(Integer, default=0 )
    api_calls = Column(Integer, default=0 )
    """ api_calls_current_period: identifies the current period. e.g. 'June' or '2020' """
    api_calls_current_period = Column(String(20), default=0 )
    """ this is the subscriber. all the users they create have a pointer
       to this table row, but only the user in this column owns the subscription """
    creator_id = Column(Integer, ForeignKey("user.id") )



